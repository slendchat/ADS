
# Лабараторная номер 6 по алгоритмам и структурам данных

## Общий анализ алгоритмов
По проведению замеров длительности работы алгоритмов сортировки и поиска были полученны следующие результаты:

Алгоритмы сортировки:\
Размер массива 100 элементов.
| Алгоритм\порядок     | случайный порядок | по возрастанию | по убыванию  |
|----------------------|-------------------|----------------|--------------|
| selectionSort        | 59.4microsec           | 55.6microsec        | 69microsec        |
| bubbleSort           | 141microsec            | 89.6microsec        | 148.6microsec     |
| bubbleSort recursive | 145microsec            | 84.8microsec        | 154microsec       |
| quickSort            | 69microsec             | 52microsec          | 190microsec       |
| MergeSort            | 332microsec            | 322microsec         | 316microsec       |

Размер массива 1000 элементов.
| Алгоритм\порядок     | случайный порядок | по возрастанию   | по убыванию    |
|----------------------|-------------------|------------------|----------------|
| selectionSort        | 4.2 миллисекунды  | 4 миллисекунды   | 6 миллисекунд  |
| bubbleSort           | 12 миллисекунд    | 8 миллисекунд    | 14 миллисекунд |
| bubbleSort recursive | 12 миллисекунд    | 8 миллисекунд    | 14 миллисекунд |
| quickSort            | 6.8 миллисекунд   | 4.4 миллисекунды | 17 миллисекунд |
| MergeSort            | 3 миллисекунды    | 3 миллисекунды   | 3 миллисекунды |

Размер массива 50000 элементов.
| Алгоритм\порядок     | случайный порядок | по возрастанию | по убыванию |
|----------------------|-------------------|----------------|-------------|
| selectionSort        | 11 сек.           | 11 сек.        | 16.6 сек    |
| bubbleSort           | 30.6 сек.         | 31 сек         | 35.2 сек    |
| bubbleSort recursive | 31 сек.           | 32 сек         | 35 сек      |
| quickSort            | 23 сек.           | 23.6 сек       | 43 сек      |
| MergeSort            | 31.2 миллисек.    | 31 миллисек.   | 25.4 сек.   |



\
\
Алгоритмы поиска:\
размер массива 50000 элементов.
| Алгоритм      | время           |
|---------------|-----------------|
| Linear Search | 123.4 Microsec. |
| Binary Search | 420 Nanoosec.   |

размер массива 200000 элементов.
| Алгоритм      | время           |
|---------------|-----------------|
| Linear Search | 123.4 Microsec. |
| Binary Search | 420 Nanoosec.   |

размер массива 1000000 элементов.
| Алгоритм      | время           |
|---------------|-----------------|
| Linear Search | 149.8 Microsec. |
| Binary Search | 1200 Nanoosec.  |

### Вывод по замерам скорости выполнения
Из полученных результатов следует что длительность выполнения алгоритмов зависит от размера данного им массива.
Также можно сказать что длительность сортировки массивов изменяется в зависимости от того в каком порядке находятся элементы массива.
Наибольшее время сортировки в среднем у массивов отсортированных предварительно в убывающем порядке, так как для отсортировки таких массивов требуется переместить все элементы, быстрее всех же сортируются и так уже отсортированные массивы, в таком случае время выполнения минимальное что соответствует лучшему времени выполнения алгоритма. Также можно заметить, что с увеличением размеров массива для сортировки некоторые алгоритмы начинают выполнятся быстрее остальных хотя на массивах малого размера они могли быть медленнее остальных, конкретно можно сказать о том что quickSort выполняется быстро на массивах малого размера, однако с массивами больших размеров становится медленнее в сравнении с остальными, в свою очередь MergeSort становиться лидером по скорости выполнения при работе с массивами больших размеров.

## Анализ двух алгоритмов.
Принцип работы Quick Sort:\
Сначала выбирается опорный элемент, он может быть любым в массиве.
Массив разбивается на три подгруппы: элементы большие меньшие и равные опорному элементу.
Для подгрупп больше в длину единицы рекурсивно выполнить все то же самое(только для больших и меньших).\
Время выполнения:\
В среднем случае QuickSort имеет временную сложность O(n log n).\
В худшем случае (если всегда выбирать крайний элемент в отсортированном массиве) - O(n^2).\
Память:\
QuickSort обычно требует O(n) дополнительной памяти стэка для рекурсии и O(1) для дополнительных переменных.\
\
Принцип работы Merge Sort:\
Массив делиться пополам до тех пор пока не останется один элемент в каждом подмассиве а затем объединяется увеличиваясь в 2 раза соблюдая порядок сортировки до тех пор пока не объединится в единый массив.\
Время выполнения:\
Всегда имеет временную сложность O(nlogn).\
Память:\
Затрачивается память на подмассивы O(n), а также O(1)

Алгоритм quickSort относительно прост в реализации, а также является одним из быстродействующих алгоритмов на маллых массивах, требует мало памяти и в целом допускает эффективную модификацию имеет крайне серьезный недостаток, а именно сильно вырастает временная сложность до O(n^2).
MergeSort же не имеет "сложностей" с входными данными и всегда имеет одинаковую временную сложность, а также очень хорош на массивах больших размеров. Однако из недостатков можно заметить что скорость выполнения алгоритма не измениться если сортировать массив с элементами в случайном порядке и уже отсортированный массив. Также требует большое количество памяти, что может стать проблемой если ее размеры ограничены.\

## Мои алгоритмы
Я написал Interpolation Search и Insertion Sort.\
Сложность по времени у Interpolation Search в лучшем случае O(1) то есть попадание в первой же итерации цикла, но в среднем это O(log(log(n))) в худшем же случае O(n).
Сложность по памяти составляет O(1), то есть лишь переменные используемые для реализации алгоритма.

Сложность по времени у Insertion Sort O(n^2), что значит данный алгоритм эффективен лишь в маленьких по размеру массивах.
Сложность по памяти составляет также O(1), потому что не требует дополнительной памяти кроме той что используется переменными.